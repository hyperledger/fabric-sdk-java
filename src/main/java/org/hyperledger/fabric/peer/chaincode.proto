// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

option java_package = "org.hyperledger.fabric.protos.peer";
option go_package = "github.com/hyperledger/fabric-protos-go/peer";

package protos;

import "common/policies.proto";

//ChaincodeID contains the path as specified by the deploy transaction
//that created it as well as the hashCode that is generated by the
//system for the path. From the user level (ie, CLI, REST API and so on)
//deploy transaction is expected to provide the path and other requests
//are expected to provide the hashCode. The other value will be ignored.
//Internally, the structure could contain both values. For instance, the
//hashCode will be set when first generated using the path
message ChaincodeID {
    //deploy transaction will use the path
    string path = 1;

    //all other requests will use the name (really a hashcode) generated by
    //the deploy transaction
    string name = 2;

    //user friendly version name for the chaincode
    string version = 3;
}

// Carries the chaincode function and its arguments.
// UnmarshalJSON in transaction.go converts the string-based REST/JSON input to
// the []byte-based current ChaincodeInput structure.
message ChaincodeInput {
    repeated bytes args  = 1;
    map<string, bytes> decorations = 2;

    // is_init is used for the application to signal that an invocation is to be routed
    // to the legacy 'Init' function for compatibility with chaincodes which handled
    // Init in the old way.  New applications should manage their initialized state
    // themselves.
    bool is_init = 3;
}

// Carries the chaincode specification. This is the actual metadata required for
// defining a chaincode.
message ChaincodeSpec {

    enum Type {
        UNDEFINED = 0;
        GOLANG = 1;
        NODE = 2;
        CAR = 3;
        JAVA = 4;
    }

    Type type = 1;
    ChaincodeID chaincode_id = 2;
    ChaincodeInput input = 3;
    int32 timeout = 4;
}

// Specify the deployment of a chaincode.
// TODO: Define `codePackage`.
message ChaincodeDeploymentSpec {
    // Prevent removed tag re-use
    reserved 2, 4;
    reserved "effective_date", "exec_env";

    ChaincodeSpec chaincode_spec = 1;
    bytes code_package = 3;

}

// Carries the chaincode function and its arguments.
message ChaincodeInvocationSpec {
    // Prevent removed tag re-use
    reserved 2;
    reserved "id_generation_alg";

    ChaincodeSpec chaincode_spec = 1;
}

// LifecycleEvent is used as the payload of the chaincode event emitted by LSCC
message LifecycleEvent {
    string chaincode_name = 1;
}

// CDSData is data stored in the LSCC on instantiation of a CC
// for CDSPackage.  This needs to be serialized for ChaincodeData
// hence the protobuf format
message CDSData {
    bytes hash = 1; // hash of ChaincodeDeploymentSpec.code_package
    bytes metadatahash = 2; // hash of ChaincodeID.name + ChaincodeID.version
}

// ChaincodeData defines the datastructure for chaincodes to be serialized by proto
// Type provides an additional check by directing to use a specific package after instantiation
// Data is Type specific (see CDSPackage and SignedCDSPackage)
message ChaincodeData {

    // Name of the chaincode
    string name = 1;

    // Version of the chaincode
    string version = 2;

    // Escc for the chaincode instance
    string escc = 3;

    // Vscc for the chaincode instance
    string vscc = 4;

    // Policy endorsement policy for the chaincode instance
    common.SignaturePolicyEnvelope policy = 5;

    // Data data specific to the package
    bytes data = 6;

    // Id of the chaincode that's the unique fingerprint for the CC This is not
    // currently used anywhere but serves as a good eyecatcher
    bytes id = 7;

    // InstantiationPolicy for the chaincode
    common.SignaturePolicyEnvelope instantiation_policy = 8;
}
